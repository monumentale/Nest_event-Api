import { Injectable, ForbiddenException } from "@nestjs/common";
import { InjectModel } from "@nestjs/mongoose";
import { Model } from "mongoose";
import * as bcrypt from "bcryptjs";
import * as moment from "moment";
import { User } from "./user.model";
import { Roles } from "../roles/roles.defined";

@Injectable()
export class UserService {
    
    constructor(@InjectModel("UserSchema") private readonly userModel: Model<User>){ }

    //@Post()
    async addUser(firstName: string, lastName: string, password: string, role?: string, email?: string): Promise<User> {
        //hash password
        const hashedPassword = await this.hashPassword(password);
        if(await this.doesUserExists(email, hashedPassword)){
            throw new ForbiddenException("This user already exists");
        }

        const user = new this.userModel({ 
            firstName, 
            lastName, 
            password: hashedPassword, 
            role, 
            email 
        });
        return await user.save() as User;
    }

    async addOrganizer(
        firstName: string, 
        lastName: string, 
        password: string, 
        role?: string, 
        email?: string,
        companyName?: string,
        companyEmail?: string, 
        companyAddress?: string, 
        companyPhone?: string
    ): Promise<User> {
        //hash password
        const hashedPassword = await this.hashPassword(password);

        if(await this.doesUserExists(email, hashedPassword)){
            throw new ForbiddenException("Username and Password already exist");
        }

        const user = new this.userModel({
            firstName,
            lastName,
            password: hashedPassword,
            role,
            email,
            companyAddress,
            companyName,
            companyEmail,
            companyPhone
        });
        return user.save() as User;
    }

    //@Get()
    async getAllUsers(): Promise<User[]> {
        return await this.userModel
                         .find({ })
                         .sort({ dateCreated: "desc" })
                         .select({ 
                            firstName: 1,
                            lastName: 1,
                            email: 1,
                            dateCreated: 1,
                            role: 1
                        })
                        .exec() as User[];
    }

    //@Get()
    async getAllUsersByRole(role: string): Promise<User[]> {
        return await this.userModel
                         .find({ role })
                         .sort({ dateCreated: "desc" })
                         .select({ 
                            firstName: 1,
                            lastName: 1,
                            email: 1,
                            dateCreated: 1,
                            role: 1
                        })
                        .exec() as User[];
    }

    //@Get()
    async getUserById(userId: string): Promise<any> {
        return await this.userModel
                         .findOne({ _id: userId })
                         .select({
                            firstName: 1,
                            lastName: 1,
                            email: 1,
                            dateCreated: 1,
                            role: 1
                         })
                         .exec() as User;
    }

    //@Get()
    //Email serves as 'Username'
    async getUserByEmailAndPassword(username: string, password: string): Promise<any> {
        const user = await this.userModel.findOne({ 
                                        email: username
                                    })
                                    .select({ 
                                        firstName: 1,
                                        lastName: 1,
                                        email: 1,
                                        dateCreated: 1,
                                        password: 1,
                                        role: 1 
                                    })
                                    .exec() as User;
        if(user) {
            //compare the plain password with hash generated by bcrypt
            if(await this.comparePasswordWithHash(password, user.password)){
                return user;
            }
        }
    }

    //@Get()
    async countAllUsers(): Promise<number> {
        try {
            return await this.userModel.find({ }).countDocuments().exec() as number;
        }
        catch(ForbiddenException) {
            throw new ForbiddenException("Count failed");
        }
    }

    //@Get()
    async countByRole(role: string): Promise<number> {
        try {
            return await this.userModel.find({ role }).countDocuments().exec() as number;
        }
        catch(ForbiddenException) {
            throw new ForbiddenException("Count failed");
        }
    }

    //@Delete()
    async deleteUserById(userId: string): Promise<any> {
        try {
            await this.userModel.deleteOne({ _id: userId }).exec();
            return { message: "User Deleted" };
        }
        catch(ForbiddenException) {
            throw new ForbiddenException("Delete failed");
        }
    }

    //@Patch()
    async updateAttendeeUser(
        _id: string, 
        firstName?: string, 
        lastName?: string,
        password?: string, 
        role?: string, 
        email?: string,
        companyName?: string,
        industry?: string,
        website?: string,
        companyEmail?: string,
        companyPhone?: string,
        companyAddress?: string
    ): Promise<User> {
        try {
            //Get the user
            const user = await this.userModel.findById(_id);
            if(user) {
                //check all fields and modify
                if(firstName && user.firstName !== firstName) {
                    user.firstName = firstName;
                }
                if(lastName && user.lastName !==lastName) {
                    user.lastName = lastName;
                }
                if(password) {
                    //hash password
                    const hashedPassword = await this.hashPassword(password);
                    if(user.password != hashedPassword) {
                        user.password = hashedPassword;
                    }
                }
                if(email && user.email != email){
                    user.email = email;
                }
                if(role && user.role !== role){
                    user.role = role;
                }
                //if the user is an Organizer Edit values for the given user
                if(role && user.role === Roles.Organizer) {
                    if(companyName && user.companyName !== companyName) {
                        user.companyName = companyName;
                    }
                    if(industry && user.industry !== industry){
                        user.industry = industry;
                    }
                    if(website && user.website != website) {
                        user.website = website;
                    }
                    if(companyEmail && user.companyEmail !== companyEmail) {
                        user.companyEmail = companyEmail;
                    }
                    if(companyAddress && user.companyAddress !== companyAddress) {
                        user.companyAddress = companyAddress;
                    }
                    if(companyPhone && user.companyPhone !== companyPhone) {
                        user.companyPhone = companyPhone;
                    }
                }
            }

            return await user.save();
        }
        catch(ForbiddenException) {
            throw new ForbiddenException("User update failed");
        }
    }

    //Hash Password
    //Code for hashing passwords using bcrypt
    async hashPassword(password: string): Promise<any> {
        const saltRounds: number = 10;
        const hashedPassword = await new Promise((resolve, reject) => {
            //hash password
            bcrypt.hash(password, saltRounds, (err, hash) => {
                if(err) {
                    reject(err);
                }
                resolve(hash);
            })
        });

        return hashedPassword;
    }

    async comparePasswordWithHash(plainPassword: string, hashedPassword: string): Promise<boolean> {
        return await bcrypt.compare(plainPassword, hashedPassword);
    }

    /**
     * Generate random One-Time-Password using Moments.js
     */
    async generateOneTimePassword(): Promise<any> {
        const randomString: string = moment().format() + moment().toISOString() + moment().unix();
        const saltRounds: number = 10;
        const oneTimeRecoveryPassword = await new Promise((resolve, reject) => {
            //hash password
            bcrypt.hash(randomString, saltRounds, (err, hash) => {
                if(err) {
                    reject(err);
                }
                resolve(hash);
            });
        });

        return oneTimeRecoveryPassword;
    }

    async getUserOneTimeValidatorByEmail(email: string): Promise<any> {
        const user: User = await this.userModel.findOne({ email }).exec();
        const oneTimeValidatorString: string = await this.generateOneTimePassword();

        if(!user){
            throw new ForbiddenException("User not found");
        }
        user.oneTimeValidator = oneTimeValidatorString;
        
        await this.userModel.findByIdAndUpdate(user._id, user, { new: true, useFindandModify: false });
        const newUser = {
            _id: user._id,
            firstName: user.firstName,
            lastName: user.lastName,
            email: user.email,
            role: user.role,
            oneTimeValidator: user.oneTimeValidator
        };

        return newUser;
    }

    async validateOneTimeIdentifier(oneTimeIdentifier: string): Promise<User> {
        const user: User = await this.userModel.findOne({ 
            oneTimeValidator: oneTimeIdentifier 
        })
        .exec();
        return user as User;
    }

    async updatePassword(newPassword: string, userId: string): Promise<any> {
        const user = await this.userModel.findById(userId);
        const hashedPassword = await this.hashPassword(newPassword);
        if(!user || !user.OneTimeValidator){
            throw new ForbiddenException("No one time validator string was found");
        }
        //update Password field
        user.password = hashedPassword;
        //clear out the current "OneTimeValidator" so a new one can easily be generated next time
        user.OneTimeValidator = null;
        
        const updatedUser: User = await user.save();
        return {
            _id: updatedUser._id,
            firstName: updatedUser.firstName,
            lastName: updatedUser.lastName,
            email: updatedUser.email,
            role: updatedUser.role,
            dateCreated: updatedUser.dateCreated
        };
    }

    //Email Address serves as the Username
    async getUserByPayload(payload: any): Promise<User> {
        const { email } = payload;
        return await this.userModel.findOne({ email });
    }

    private async doesUserExists(email: string, password: string){
        return await this.userModel.exists({ email, password });
    }
}